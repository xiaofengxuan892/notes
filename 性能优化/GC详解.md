[TOC]



**概述**：“内存垃圾”是指废弃数据占用的内存，而垃圾回收(GC)是将“废弃数据占用的内存”进行回收的过程

##### Unity的内存管理机制：

Unity引擎针对内存管理主要采取“自动”机制，开发人员无需在代码中设定对象的“回收”，由引擎自动执行。针对“值类型”和“引用类型”变量分别在“栈”和“托管堆”中分配内存，“栈”中的内存回收非常迅速，而“托管堆”中的内存回收则需要等待Unity定时调用GC来进行。而**<font color=red>垃圾回收(GC)也主要是针对“托管堆”中分配的对象</font>**



##### 在“托管堆”中为变量分配内存的过程：

1).检测“托管堆”中是否有足够大小的内存分配给该变量，如果有则直接分配该内存单元即可

2).如果没有足够大小的内存单元，则Unity会触发“垃圾回收(GC)”来释放“托管堆”中“废弃数据占用的内存”，其具体过程为：遍历“托管堆”中每个变量，确定其是否处于“激活状态”。若该对象不处于“激活状态”，则将其占用的内存从“托管堆”中释放。**<font color=red>GC是一个极其耗费时间的操作，尤其在“托管堆”中变量很多时，由于需要检查每个变量是否处于“激活状态”，因此其耗时会极长</font>**。

3).如果垃圾回收后“托管堆”中有足够大的内存单元分配给该对象，则进行内存分配；如果没有，则**<font color=red>Unity会触发“内存扩展”，该过程极为缓慢</font>**

4).当“内存扩展”结束后，则在“托管堆”中为该对象分配内存单元

**垃圾回收(GC)和“内存扩展”都是极为耗时的操作，会极大的影响游戏性能**，因此需要**<font color=blue>妥善的管理游戏中对象的创建和使用，尽可能避免“在为对象分配内存”时触发GC和“内存扩展”</font>**

###### “激活状态”的判定标准：

引擎内部会根据该对象是否被其他地方引用来确定其是否处于“激活状态”。日常开发时，也可以在代码中**<font color=red>将不需要使用的对象设置为“null”以加速该判定过程</font>**。

**注意**：若将某个对象设置为“null”或该对象已不处于“激活状态”，**<font color=red>其占用的内存也不会马上被自动回收，需要等待GC执行后才会释放其占用的内存</font>**



##### 触发垃圾回收的时机：

1).当需要在“托管堆”中为某个变量分配内存时，如果“托管堆”中没有足够大的内存单元，则需要触发垃圾回收以释放“废弃数据占用的内存”

2).Unity在不同平台设定了GC的触发频率，当满足指定时间后则会自动触发以释放“托管堆”中“废弃数据占用的内存”

3).部分特殊情况，如游戏运行时遇到“内存严重不足”的情况(可使用`Application.lowMemory`监测)，可在代码中手动触发：`GC.Collect()`。但由于GC耗时较长，故非特殊情况不建议在代码中手动触发



##### 垃圾回收(GC)引发的问题：

1).首先垃圾回收是一个极为耗时的过程，其会检查“托管堆”中的每个变量以确定其是否可以被回收。当“托管堆”中对象较多时，则耗时更长

2).如果GC触发的频率较高，则其在“游戏关键时刻”触发的概率也会提升，此时会对游戏产生致命的影响

3).垃圾回收(GC)可以将废弃数据占用的内存重新放入“托管堆”中，但有可能不是以“一整块”，而是以“多个零碎内存单元”的形式被重新放入“托管堆”。这会导致**<font color=red>“托管堆”的“碎片化”</font>**。当“碎片化”较严重时，则可能出现如下情况：**<font color=red>“托管堆”有很多内存单元，但普遍容量较小，当需要为某个对象分配内存时，无法找到满足其需求大小的内存单元</font>**，此时又会触发GC和“内存扩展”。**如此情况越发恶化**，最终游戏会**<font color=blue>占用设备上极大的内存</font>**，且GC触发频率也会越高

GC导致的问题在视觉体现上则是“游戏运行的帧率较低”，性能间歇性降低或中断



##### 针对GC的优化策略：

1).减少GC触发的次数

由于“为对象分配内存”和“Unity内部定时触发GC”无法避免，因此需要减少主动调用“GC.Collect()”的次数，非特殊情况禁止调用该方法

2).降低GC耗费的时间

减少新对象的分配，充分利用已有对象，如“对象池”和“引用池”等

3).避免GC在游戏关键时刻触发

自主选择“触发GC.Collect()”的时机，如在“加载新场景”时，可调用“GC.Collect()”释放内存。该方式并不能完全避免，但可以降低“游戏关键时刻触发GC”的概率



##### 其他优化细节：

1.项目中针对“日志输出”最好封装“专用的Log模块”，其内部使用“Conditional”或“宏指令”来限定日志输出的条件。在游戏正式包中，“日志输出”会影响游戏性能，而且也不安全，因此“正式包”中除了某个必要信息外，其他“非重要日志”都需要关闭，如Debug.Log语句等

2.数学运算中减少“除法”的使用，通过“+、-、x”来代替，减少资源消耗

3.删除脚本中“方法体为空”的方法，包括“方法体内容为空”的Start、Update，以及其他自定义方法等

4.使用默认的Vector3.One，而不是new Vector3(1, 1, 1)

5.不要在循环中多次调用GetComponent或GameObject.Find等方法，使用CompareTag替代“直接获取物体的tag属性”

6.当涉及到字符串拼接时，使用StringBuilder替代：原生的string在修改字符串内容后都会生成新的string对象，多次修改string后容易生成更多GC

7.全局变量和局部变量：全局变量在程序运行之初就分配了内存，直等到整个程序运行结束后才会回收其占用的内存。但局部变量是只有在脚本运行到这个方法时才会为这个变量分配内存，等到这个方法执行完毕后就回收这个局部变量占用的内存。因此为节省资源可以尽量少声明全局变量

8.在游戏中，各个GameObject会占用大量的内存，因此当需要实例化多个GameObject时，接入“对象池系统”用于管理，可以很好的控制占用的内存总量

9.尽量不要使用GUI绘制组件，相比于UGUI，GUI会耗费更多资源

10.少用LINQ语句，会产生大量GC，且部分功能在某些平台无法使用

11.减少StartCoroutine的次数：开启一个协程Coroutine至少会分配37B的内存，使用UniTask替代。并且使用“yield return null”代表“yield return 0”，避免装箱操作。减少“yield return new xxxx”中“new xxx”的次数，当需要频繁返回某个时间如“new WaitForSecond(1f)”时，则可将该对象先缓存起来，避免每次都调用“new”创建实例

12.获取物体的name，如“object.name”会分配39B的堆内存

13.使用Input.GetTouch()和Input.touchCount来代替Input.touches，使用Physics.SphereCastNonAlloc()来代替Physics.SphereCastAll()

14.**<font color=red>Resource.UnloadUnusedAssets()比较耗时，建议在“切换场景”的时候进行</font>**

**注意**：struct是值类型变量，但**<font color=blue>如果其内部包含“引用类型”变量，如string等，则需要等待GC才能回收其内存占用</font>**。因此**<font color=red>不建议在struct中声明“引用类型”变量</font>**



##### Reserved预分配内存：

在Profile面板中的“Memory Profiler”中，“Reserved”是指：为了保证游戏的正常运行而向操作系统申请的内存。在游戏运行中，当需要为某个对象分配内存时，则先从“Reserved”中申请内存；当释放内存时，“被释放的内存”也是先回到“Reserved”中

<img src="https://gitee.com/kakaix892/image-host/raw/main/Typora/image-20231108205248858.png" alt="image-20231108205248858" style="zoom:80%;" />





























