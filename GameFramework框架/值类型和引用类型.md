[TOC]



### 从<font color=red>宏观角度</font>看待“值类型”和“引用类型”：

#### 基础环境：

1.“System.Object”是所有类型的基类，无论“值类型”或“引用类型”，都是“System.Object”的子类。只是“引用类型”直接继承自“System.Object”，而“值类型”则继承自“System.Object的子类 —— System.ValueType”

2.所有的“System.Object”子类中都包含“ToString”，"Equals"，“Clone”方法。



#### 扩展延申：

**<font color=red>问题：已经有“System.Object”了，为什么还需要单独分离出一个“System.Object的子类” ——System.ValueType ?</font>**

**原因**：在实际开发中，“System.Object”默认为“引用类型”，该类型对象通常在“堆”中分配内存空间，并且其中只存储“真实数据所在的地址”，而“不存储真实数据本身”。**<font color=red>在部分情况下，这些类型会极大的降低开发效率和程序性能</font>**。因此，**<font color=red>从“System.Object”中单独提取出“System.ValueType”类型</font>**，以满足这些数据的需求



#### 设定“System.ValueType”类型的细节：

1.该类型的对象可以**<font color=red>直接存储数据本身</font>**，并且为了提升存取效率，**<font color=red>直接在“栈”中为其分配内存空间</font>**。

2.为了方便使用“System.ValueType”变量，并且与“System.Object”变量区分开，重写基类的“Equals”和“Clone”方法：

**重写“Equals”方法**：由于“值类型”中存储的是“数据本身”，因此直接比较两个数值即可

**重写“Clone”方法**：在为“值类型”变量赋值时，是将该“该数据本身”拷贝一份，之后赋值给新变量，并且两个变量之间没有任何直接联系。因此如果之后修改其中一个变量，是不会对另一变量有任何影响的。

**PS**：在“基类的Clone”方法中，如果为某个“引用类型”变量赋值，是将本变量“指向的真实数据的地址”赋值给另一变量。两个变量指向的是“同一地址的数据”。之后若该数据本身发生改变，则两个变量都会有影响

3.**<font color=red>由于“System.ValueType”类型的数据需求较低，仅有少量数据需要为“System.ValueType”类型</font>**，如：

```c#
struct结构，enum枚举，char字符，bool类型，int/float/short/long/byte/decimal等数值类型
```

**其他的数据则默认保持为“System.Object”类型**。

并且**<font color=red>为了方便控制这些值类型，所有的值类型都必须是“sealed”修饰，以避免“通过继承扩展得到新的值类型”</font>**

**而对于“引用类型”则不需要此限制，因此“引用类型”可以通过“继承”得到“更多的引用类型”，即俗称的“多态”**

4.**其他方面的设定**：

“值类型”由于数据简单，因此为提升效率，通常直接在“栈”中为其分配内存，并且**<font color=red>所有的“值类型”变量在创建之后都有专属的“默认赋值”</font>**；但为了丰富“值类型的功能”，**提供“可空修饰符 —— ?”，允许为“值类型变量”赋值为“null”**。**<font color=red>此时的“值类型变量”则在“堆”中为其分配内存空间</font>**。

**而对于“引用类型”变量，则只能在“堆”中为其分配内存空间，并且默认赋值为null**



struct是值类型，因此其也是“sealed”修饰，不支持继承其他struct，或被其他struct继承，但其可以实现“接口interface”



**PS**：1.**“小写的object”是“System.Object”的别名**，两者是等价的；同理，**“小写的string”则是“System.String”的别名**

2.**“小写的class”，派生自“System.Object”**，是“引用类型”





#### 值类型与引用类型在方法体中的使用：

```c#
int num = 20;
string strValue = "OK";
int[] arr = { 1, 2, 3 };
int[] arr2 = { 4, 5, 6 };

void Start(){
    ValueMethod(strValue, num, arr, arr2);
    Debug.Log("METHOD 1: " + strValue + "    " + num + "    " + arr[0] + "   " +  arr2[0]);
    ValueMethod2();
    Debug.Log("METHOD 2: " + strValue + "    " + num + "    " + arr[0] + "   " +  arr2[0]);
}

void ValueMethod(string strValue, int num, int[] arr, int[] arr2)
{
    strValue = "hello";//strValue为引用类型，但此处更改的是另一同名局部变量“strValue”的地址指向。因此局部变量strValue指向“hello”的新的地址
    num = 100;      //将全局变量num的数值提供一份副本赋值给局部变量“num”——全局变量num和此方法体中的局部变量“num”没有任何直接关联
    arr[0] = -10;//将全局变量arr的地址赋值给局部变量“arr”，两者指向同一地址。此代码直接更改地址指向的内容本身，故全局和局部变量arr都会改变
    arr2 = new int[3] { 7, 8, 9 }; //首先将全局变量arr2的地址赋值给局部变量arr2，然后此代码将局部变量arr2指向新的地址。故全局变量arr2不受影响
}

void ValueMethod2()
{
    strValue = "hello";
    num = 100;
    arr[0] = -10;
    arr2 = new int[3] { 7, 8, 9 };
}
```

执行结果：

<img src="https://gitee.com/kakaix892/image-host/raw/main/Typora/image-20231106183120124.png" alt="image-20231106183120124" style="zoom:80%;" />

总结：

**1.当方法中有参数时，****首先执行的是将外部的全局变量赋值给方法体中的局部变量****，而后所有的操作都是==基于此局部变量的基础上来执行的==**

**2.值类型变量作为参数向方法体中传值时，使用的是该值变量的副本，无论如何也不会影响到值变量本身；引用类型传值时，使用的是该引用变量的地址，是有可能影响到本身的**

3.string是特殊的引用类型，当将其用于赋值时，使用的是其“副本”，而非“引用地址”

```c#
string a = "hello";         //声明一个引用类型的变量，内容是hello，a指向这个变量，a中存放的是该变量所在的地址
string b = a；              //声明一个指向hello的引用(和a同样指向)，b中存放的是地址
a = "test";                //a指向test，a存放test所在的地址 。这里改变的是指向，而不是内容本身，即“hello”这个内容模块并没有被改变。
Debug.Log(a + "" + b);     //输出：test hello
```



### Equals和“`==`”的作用：

默认情况下，无论“`==`”或“Equals”，针对值类型则比较的是两者的内容本身，针对引用类型则比较的是两者的地址。

但是部分引用类型会重写“Equals”和“`==`”方法，如“string”，此时则按照重写之后的逻辑来执行

- ==“Equals”与“`==`”并不等价，重写“Equals”并不代表重写了“`==`”==。大多情况下，引用类型只会重写“Equals”方法，而没有重写“`==`”，因此当调用“`==`”时依然按照原有逻辑比较其“地址”，而调用“Equals”时则按照重写后的逻辑来执行。如此“Equals”和“==”执行的结果即出现差异
- ==针对未知类型，如泛型，由于不知道具体会处理哪种类型的数据，因此相较于“`==`”，使用“Equals”会更安全==



### 装箱和拆箱详解：

装箱和拆箱的定义：将“值类型”转换成“引用类型”即为“装箱”，“拆箱”则与此过程相反。值类型对象直接在“栈”中分配内存，而引用类型对象则在“托管堆”中分配内存(“托管堆”对应后续的“垃圾回收”)

#### 装箱和拆箱的内部过程：

**装箱操作**：

<img src="https://gitee.com/kakaix892/image-host/raw/main/Typora/image-20231112194909589.png" alt="image-20231112194909589" style="zoom: 67%;" />

对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。按三步进行。 
1：首先从托管堆中为新生成的引用对象分配内存(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。 
2：然后将值类型的数据拷贝到刚刚分配的内存中。 
3：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。
可以看出，进行一次装箱要进行分配内存和拷贝数据这两项比较影响性能的操作。

**PS**：o 和 i 的改变将互不影响，因为装箱使用的是 i 的一个副本。

**拆箱操作**：

<img src="https://gitee.com/kakaix892/image-host/raw/main/Typora/image-20231112195314297.png" alt="image-20231112195314297" style="zoom: 67%;" />

1、首先获取托管堆中属于值类型那部分字段的地址，这一步是严格意义上的拆箱。
2、将引用对象中的值拷贝到位于线程堆栈上的值类型实例中。
经过这2步，可以认为是同boxing是互反操作。严格意义上的拆箱，并不影响性能，但伴随这之后的拷贝数据的操作就会同boxing操作中一样影响性能。

PS：o 和 i 的改变将互不影响（已验证）

#### 问题：什么情况下需要装箱？

解答：当声明一个方法中的参数时，为了让该方法可以支持多种类型的参数，故将其设置为“object类型”。或者当声明一个集合时，为了兼容多种类型的元素，则会将该集合声明为“`List<object>`”。当把“值类型”的数据传递到方法或放入集合中时，则需要对该数据进行“装箱”

#### 装箱、拆箱对执行效率的影响：

显然，从原理上可以看出，装箱时，生成的是全新的引用对象，这会有时间损耗，也就是造成效率降低。 那该如何做呢？ 
首先，应该尽量避免装箱。 
比如上例2的两种情况，都可以避免，在第一种情况下，可以通过重载函数来避免。第二种情况，则可以通过泛型来避免。 
当然，凡事并不能绝对，假设你想改造的代码为第三方程序集，你无法更改，那你只能是装箱了。 
对于装箱/拆箱代码的优化，由于C#中对装箱和拆箱都是隐式的，所以，根本的方法是对代码进行分析，而分析最直接的方式是了解原理结合查看反编译的IL代码。比如：在循环体中可能存在多余的装箱，你可以简单采用提前装箱方式进行优化































